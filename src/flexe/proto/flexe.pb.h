// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flexe.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flexe_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flexe_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flexe_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flexe_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flexe_2eproto;
namespace flexe {
class EvaluateReply;
struct EvaluateReplyDefaultTypeInternal;
extern EvaluateReplyDefaultTypeInternal _EvaluateReply_default_instance_;
class GenericRequest;
struct GenericRequestDefaultTypeInternal;
extern GenericRequestDefaultTypeInternal _GenericRequest_default_instance_;
class GenericResponse;
struct GenericResponseDefaultTypeInternal;
extern GenericResponseDefaultTypeInternal _GenericResponse_default_instance_;
class ModelReply;
struct ModelReplyDefaultTypeInternal;
extern ModelReplyDefaultTypeInternal _ModelReply_default_instance_;
class ModelRequest;
struct ModelRequestDefaultTypeInternal;
extern ModelRequestDefaultTypeInternal _ModelRequest_default_instance_;
class TTRequest;
struct TTRequestDefaultTypeInternal;
extern TTRequestDefaultTypeInternal _TTRequest_default_instance_;
}  // namespace flexe
PROTOBUF_NAMESPACE_OPEN
template<> ::flexe::EvaluateReply* Arena::CreateMaybeMessage<::flexe::EvaluateReply>(Arena*);
template<> ::flexe::GenericRequest* Arena::CreateMaybeMessage<::flexe::GenericRequest>(Arena*);
template<> ::flexe::GenericResponse* Arena::CreateMaybeMessage<::flexe::GenericResponse>(Arena*);
template<> ::flexe::ModelReply* Arena::CreateMaybeMessage<::flexe::ModelReply>(Arena*);
template<> ::flexe::ModelRequest* Arena::CreateMaybeMessage<::flexe::ModelRequest>(Arena*);
template<> ::flexe::TTRequest* Arena::CreateMaybeMessage<::flexe::TTRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flexe {

// ===================================================================

class GenericRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.GenericRequest) */ {
 public:
  inline GenericRequest() : GenericRequest(nullptr) {}
  ~GenericRequest() override;
  explicit constexpr GenericRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericRequest(const GenericRequest& from);
  GenericRequest(GenericRequest&& from) noexcept
    : GenericRequest() {
    *this = ::std::move(from);
  }

  inline GenericRequest& operator=(const GenericRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericRequest& operator=(GenericRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericRequest* internal_default_instance() {
    return reinterpret_cast<const GenericRequest*>(
               &_GenericRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericRequest& a, GenericRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericRequest* New() const final {
    return new GenericRequest();
  }

  GenericRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericRequest& from);
  void MergeFrom(const GenericRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.GenericRequest";
  }
  protected:
  explicit GenericRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:flexe.GenericRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// -------------------------------------------------------------------

class GenericResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.GenericResponse) */ {
 public:
  inline GenericResponse() : GenericResponse(nullptr) {}
  ~GenericResponse() override;
  explicit constexpr GenericResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericResponse(const GenericResponse& from);
  GenericResponse(GenericResponse&& from) noexcept
    : GenericResponse() {
    *this = ::std::move(from);
  }

  inline GenericResponse& operator=(const GenericResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericResponse& operator=(GenericResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericResponse* internal_default_instance() {
    return reinterpret_cast<const GenericResponse*>(
               &_GenericResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GenericResponse& a, GenericResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericResponse* New() const final {
    return new GenericResponse();
  }

  GenericResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericResponse& from);
  void MergeFrom(const GenericResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.GenericResponse";
  }
  protected:
  explicit GenericResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 1,
  };
  // int32 reply = 1;
  void clear_reply();
  ::PROTOBUF_NAMESPACE_ID::int32 reply() const;
  void set_reply(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reply() const;
  void _internal_set_reply(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flexe.GenericResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 reply_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// -------------------------------------------------------------------

class TTRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.TTRequest) */ {
 public:
  inline TTRequest() : TTRequest(nullptr) {}
  ~TTRequest() override;
  explicit constexpr TTRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTRequest(const TTRequest& from);
  TTRequest(TTRequest&& from) noexcept
    : TTRequest() {
    *this = ::std::move(from);
  }

  inline TTRequest& operator=(const TTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTRequest& operator=(TTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTRequest* internal_default_instance() {
    return reinterpret_cast<const TTRequest*>(
               &_TTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TTRequest& a, TTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TTRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TTRequest* New() const final {
    return new TTRequest();
  }

  TTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TTRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TTRequest& from);
  void MergeFrom(const TTRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.TTRequest";
  }
  protected:
  explicit TTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetPathFieldNumber = 2,
    kModelNameFieldNumber = 3,
    kIdVehicleFieldNumber = 1,
    kEpochsFieldNumber = 4,
    kBatchSizeFieldNumber = 5,
  };
  // string datasetPath = 2;
  void clear_datasetpath();
  const std::string& datasetpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datasetpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datasetpath();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_datasetpath();
  void set_allocated_datasetpath(std::string* datasetpath);
  private:
  const std::string& _internal_datasetpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datasetpath(const std::string& value);
  std::string* _internal_mutable_datasetpath();
  public:

  // string modelName = 3;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // int32 idVehicle = 1;
  void clear_idvehicle();
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle() const;
  void set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idvehicle() const;
  void _internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 epochs = 4;
  void clear_epochs();
  ::PROTOBUF_NAMESPACE_ID::int32 epochs() const;
  void set_epochs(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_epochs() const;
  void _internal_set_epochs(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 batch_size = 5;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flexe.TTRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datasetpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle_;
  ::PROTOBUF_NAMESPACE_ID::int32 epochs_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// -------------------------------------------------------------------

class EvaluateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.EvaluateReply) */ {
 public:
  inline EvaluateReply() : EvaluateReply(nullptr) {}
  ~EvaluateReply() override;
  explicit constexpr EvaluateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvaluateReply(const EvaluateReply& from);
  EvaluateReply(EvaluateReply&& from) noexcept
    : EvaluateReply() {
    *this = ::std::move(from);
  }

  inline EvaluateReply& operator=(const EvaluateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvaluateReply& operator=(EvaluateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvaluateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvaluateReply* internal_default_instance() {
    return reinterpret_cast<const EvaluateReply*>(
               &_EvaluateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EvaluateReply& a, EvaluateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EvaluateReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvaluateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EvaluateReply* New() const final {
    return new EvaluateReply();
  }

  EvaluateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EvaluateReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EvaluateReply& from);
  void MergeFrom(const EvaluateReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvaluateReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.EvaluateReply";
  }
  protected:
  explicit EvaluateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLossFieldNumber = 1,
    kAccuracyFieldNumber = 2,
  };
  // double loss = 1;
  void clear_loss();
  double loss() const;
  void set_loss(double value);
  private:
  double _internal_loss() const;
  void _internal_set_loss(double value);
  public:

  // double accuracy = 2;
  void clear_accuracy();
  double accuracy() const;
  void set_accuracy(double value);
  private:
  double _internal_accuracy() const;
  void _internal_set_accuracy(double value);
  public:

  // @@protoc_insertion_point(class_scope:flexe.EvaluateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double loss_;
  double accuracy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// -------------------------------------------------------------------

class ModelReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.ModelReply) */ {
 public:
  inline ModelReply() : ModelReply(nullptr) {}
  ~ModelReply() override;
  explicit constexpr ModelReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelReply(const ModelReply& from);
  ModelReply(ModelReply&& from) noexcept
    : ModelReply() {
    *this = ::std::move(from);
  }

  inline ModelReply& operator=(const ModelReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelReply& operator=(ModelReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelReply* internal_default_instance() {
    return reinterpret_cast<const ModelReply*>(
               &_ModelReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelReply& a, ModelReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelReply* New() const final {
    return new ModelReply();
  }

  ModelReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelReply& from);
  void MergeFrom(const ModelReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.ModelReply";
  }
  protected:
  explicit ModelReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorsFieldNumber = 2,
    kIdVehicleFieldNumber = 1,
  };
  // repeated bytes tensors = 2;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;
  public:
  void clear_tensors();
  const std::string& tensors(int index) const;
  std::string* mutable_tensors(int index);
  void set_tensors(int index, const std::string& value);
  void set_tensors(int index, std::string&& value);
  void set_tensors(int index, const char* value);
  void set_tensors(int index, const void* value, size_t size);
  std::string* add_tensors();
  void add_tensors(const std::string& value);
  void add_tensors(std::string&& value);
  void add_tensors(const char* value);
  void add_tensors(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tensors();
  private:
  const std::string& _internal_tensors(int index) const;
  std::string* _internal_add_tensors();
  public:

  // int32 idVehicle = 1;
  void clear_idvehicle();
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle() const;
  void set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idvehicle() const;
  void _internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flexe.ModelReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tensors_;
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// -------------------------------------------------------------------

class ModelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flexe.ModelRequest) */ {
 public:
  inline ModelRequest() : ModelRequest(nullptr) {}
  ~ModelRequest() override;
  explicit constexpr ModelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRequest(const ModelRequest& from);
  ModelRequest(ModelRequest&& from) noexcept
    : ModelRequest() {
    *this = ::std::move(from);
  }

  inline ModelRequest& operator=(const ModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRequest& operator=(ModelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRequest* internal_default_instance() {
    return reinterpret_cast<const ModelRequest*>(
               &_ModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelRequest& a, ModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelRequest* New() const final {
    return new ModelRequest();
  }

  ModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelRequest& from);
  void MergeFrom(const ModelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flexe.ModelRequest";
  }
  protected:
  explicit ModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorsFieldNumber = 2,
    kIdVehicleFieldNumber = 1,
    kNumberOfVehiclesFieldNumber = 3,
    kNumExamplesFieldNumber = 4,
  };
  // repeated bytes tensors = 2;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;
  public:
  void clear_tensors();
  const std::string& tensors(int index) const;
  std::string* mutable_tensors(int index);
  void set_tensors(int index, const std::string& value);
  void set_tensors(int index, std::string&& value);
  void set_tensors(int index, const char* value);
  void set_tensors(int index, const void* value, size_t size);
  std::string* add_tensors();
  void add_tensors(const std::string& value);
  void add_tensors(std::string&& value);
  void add_tensors(const char* value);
  void add_tensors(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tensors();
  private:
  const std::string& _internal_tensors(int index) const;
  std::string* _internal_add_tensors();
  public:

  // int32 idVehicle = 1;
  void clear_idvehicle();
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle() const;
  void set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idvehicle() const;
  void _internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 number_of_vehicles = 3;
  void clear_number_of_vehicles();
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_vehicles() const;
  void set_number_of_vehicles(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number_of_vehicles() const;
  void _internal_set_number_of_vehicles(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_examples = 4;
  void clear_num_examples();
  ::PROTOBUF_NAMESPACE_ID::int32 num_examples() const;
  void set_num_examples(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_examples() const;
  void _internal_set_num_examples(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flexe.ModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tensors_;
  ::PROTOBUF_NAMESPACE_ID::int32 idvehicle_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_vehicles_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_examples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flexe_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GenericRequest

// string msg = 1;
inline void GenericRequest::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GenericRequest::msg() const {
  // @@protoc_insertion_point(field_get:flexe.GenericRequest.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericRequest::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flexe.GenericRequest.msg)
}
inline std::string* GenericRequest::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:flexe.GenericRequest.msg)
  return _internal_mutable_msg();
}
inline const std::string& GenericRequest::_internal_msg() const {
  return msg_.Get();
}
inline void GenericRequest::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericRequest::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericRequest::release_msg() {
  // @@protoc_insertion_point(field_release:flexe.GenericRequest.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenericRequest::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flexe.GenericRequest.msg)
}

// -------------------------------------------------------------------

// GenericResponse

// int32 reply = 1;
inline void GenericResponse::clear_reply() {
  reply_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenericResponse::_internal_reply() const {
  return reply_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenericResponse::reply() const {
  // @@protoc_insertion_point(field_get:flexe.GenericResponse.reply)
  return _internal_reply();
}
inline void GenericResponse::_internal_set_reply(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  reply_ = value;
}
inline void GenericResponse::set_reply(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reply(value);
  // @@protoc_insertion_point(field_set:flexe.GenericResponse.reply)
}

// -------------------------------------------------------------------

// TTRequest

// int32 idVehicle = 1;
inline void TTRequest::clear_idvehicle() {
  idvehicle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::_internal_idvehicle() const {
  return idvehicle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::idvehicle() const {
  // @@protoc_insertion_point(field_get:flexe.TTRequest.idVehicle)
  return _internal_idvehicle();
}
inline void TTRequest::_internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  idvehicle_ = value;
}
inline void TTRequest::set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idvehicle(value);
  // @@protoc_insertion_point(field_set:flexe.TTRequest.idVehicle)
}

// string datasetPath = 2;
inline void TTRequest::clear_datasetpath() {
  datasetpath_.ClearToEmpty();
}
inline const std::string& TTRequest::datasetpath() const {
  // @@protoc_insertion_point(field_get:flexe.TTRequest.datasetPath)
  return _internal_datasetpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTRequest::set_datasetpath(ArgT0&& arg0, ArgT... args) {
 
 datasetpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flexe.TTRequest.datasetPath)
}
inline std::string* TTRequest::mutable_datasetpath() {
  // @@protoc_insertion_point(field_mutable:flexe.TTRequest.datasetPath)
  return _internal_mutable_datasetpath();
}
inline const std::string& TTRequest::_internal_datasetpath() const {
  return datasetpath_.Get();
}
inline void TTRequest::_internal_set_datasetpath(const std::string& value) {
  
  datasetpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TTRequest::_internal_mutable_datasetpath() {
  
  return datasetpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TTRequest::release_datasetpath() {
  // @@protoc_insertion_point(field_release:flexe.TTRequest.datasetPath)
  return datasetpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TTRequest::set_allocated_datasetpath(std::string* datasetpath) {
  if (datasetpath != nullptr) {
    
  } else {
    
  }
  datasetpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datasetpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flexe.TTRequest.datasetPath)
}

// string modelName = 3;
inline void TTRequest::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& TTRequest::modelname() const {
  // @@protoc_insertion_point(field_get:flexe.TTRequest.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTRequest::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flexe.TTRequest.modelName)
}
inline std::string* TTRequest::mutable_modelname() {
  // @@protoc_insertion_point(field_mutable:flexe.TTRequest.modelName)
  return _internal_mutable_modelname();
}
inline const std::string& TTRequest::_internal_modelname() const {
  return modelname_.Get();
}
inline void TTRequest::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TTRequest::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TTRequest::release_modelname() {
  // @@protoc_insertion_point(field_release:flexe.TTRequest.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TTRequest::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flexe.TTRequest.modelName)
}

// int32 epochs = 4;
inline void TTRequest::clear_epochs() {
  epochs_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::_internal_epochs() const {
  return epochs_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::epochs() const {
  // @@protoc_insertion_point(field_get:flexe.TTRequest.epochs)
  return _internal_epochs();
}
inline void TTRequest::_internal_set_epochs(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  epochs_ = value;
}
inline void TTRequest::set_epochs(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_epochs(value);
  // @@protoc_insertion_point(field_set:flexe.TTRequest.epochs)
}

// int32 batch_size = 5;
inline void TTRequest::clear_batch_size() {
  batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TTRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:flexe.TTRequest.batch_size)
  return _internal_batch_size();
}
inline void TTRequest::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batch_size_ = value;
}
inline void TTRequest::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:flexe.TTRequest.batch_size)
}

// -------------------------------------------------------------------

// EvaluateReply

// double loss = 1;
inline void EvaluateReply::clear_loss() {
  loss_ = 0;
}
inline double EvaluateReply::_internal_loss() const {
  return loss_;
}
inline double EvaluateReply::loss() const {
  // @@protoc_insertion_point(field_get:flexe.EvaluateReply.loss)
  return _internal_loss();
}
inline void EvaluateReply::_internal_set_loss(double value) {
  
  loss_ = value;
}
inline void EvaluateReply::set_loss(double value) {
  _internal_set_loss(value);
  // @@protoc_insertion_point(field_set:flexe.EvaluateReply.loss)
}

// double accuracy = 2;
inline void EvaluateReply::clear_accuracy() {
  accuracy_ = 0;
}
inline double EvaluateReply::_internal_accuracy() const {
  return accuracy_;
}
inline double EvaluateReply::accuracy() const {
  // @@protoc_insertion_point(field_get:flexe.EvaluateReply.accuracy)
  return _internal_accuracy();
}
inline void EvaluateReply::_internal_set_accuracy(double value) {
  
  accuracy_ = value;
}
inline void EvaluateReply::set_accuracy(double value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:flexe.EvaluateReply.accuracy)
}

// -------------------------------------------------------------------

// ModelReply

// int32 idVehicle = 1;
inline void ModelReply::clear_idvehicle() {
  idvehicle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelReply::_internal_idvehicle() const {
  return idvehicle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelReply::idvehicle() const {
  // @@protoc_insertion_point(field_get:flexe.ModelReply.idVehicle)
  return _internal_idvehicle();
}
inline void ModelReply::_internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  idvehicle_ = value;
}
inline void ModelReply::set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idvehicle(value);
  // @@protoc_insertion_point(field_set:flexe.ModelReply.idVehicle)
}

// repeated bytes tensors = 2;
inline int ModelReply::_internal_tensors_size() const {
  return tensors_.size();
}
inline int ModelReply::tensors_size() const {
  return _internal_tensors_size();
}
inline void ModelReply::clear_tensors() {
  tensors_.Clear();
}
inline std::string* ModelReply::add_tensors() {
  // @@protoc_insertion_point(field_add_mutable:flexe.ModelReply.tensors)
  return _internal_add_tensors();
}
inline const std::string& ModelReply::_internal_tensors(int index) const {
  return tensors_.Get(index);
}
inline const std::string& ModelReply::tensors(int index) const {
  // @@protoc_insertion_point(field_get:flexe.ModelReply.tensors)
  return _internal_tensors(index);
}
inline std::string* ModelReply::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:flexe.ModelReply.tensors)
  return tensors_.Mutable(index);
}
inline void ModelReply::set_tensors(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:flexe.ModelReply.tensors)
  tensors_.Mutable(index)->assign(value);
}
inline void ModelReply::set_tensors(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:flexe.ModelReply.tensors)
  tensors_.Mutable(index)->assign(std::move(value));
}
inline void ModelReply::set_tensors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tensors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flexe.ModelReply.tensors)
}
inline void ModelReply::set_tensors(int index, const void* value, size_t size) {
  tensors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flexe.ModelReply.tensors)
}
inline std::string* ModelReply::_internal_add_tensors() {
  return tensors_.Add();
}
inline void ModelReply::add_tensors(const std::string& value) {
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flexe.ModelReply.tensors)
}
inline void ModelReply::add_tensors(std::string&& value) {
  tensors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flexe.ModelReply.tensors)
}
inline void ModelReply::add_tensors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flexe.ModelReply.tensors)
}
inline void ModelReply::add_tensors(const void* value, size_t size) {
  tensors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flexe.ModelReply.tensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelReply::tensors() const {
  // @@protoc_insertion_point(field_list:flexe.ModelReply.tensors)
  return tensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelReply::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:flexe.ModelReply.tensors)
  return &tensors_;
}

// -------------------------------------------------------------------

// ModelRequest

// int32 idVehicle = 1;
inline void ModelRequest::clear_idvehicle() {
  idvehicle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::_internal_idvehicle() const {
  return idvehicle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::idvehicle() const {
  // @@protoc_insertion_point(field_get:flexe.ModelRequest.idVehicle)
  return _internal_idvehicle();
}
inline void ModelRequest::_internal_set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  idvehicle_ = value;
}
inline void ModelRequest::set_idvehicle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idvehicle(value);
  // @@protoc_insertion_point(field_set:flexe.ModelRequest.idVehicle)
}

// repeated bytes tensors = 2;
inline int ModelRequest::_internal_tensors_size() const {
  return tensors_.size();
}
inline int ModelRequest::tensors_size() const {
  return _internal_tensors_size();
}
inline void ModelRequest::clear_tensors() {
  tensors_.Clear();
}
inline std::string* ModelRequest::add_tensors() {
  // @@protoc_insertion_point(field_add_mutable:flexe.ModelRequest.tensors)
  return _internal_add_tensors();
}
inline const std::string& ModelRequest::_internal_tensors(int index) const {
  return tensors_.Get(index);
}
inline const std::string& ModelRequest::tensors(int index) const {
  // @@protoc_insertion_point(field_get:flexe.ModelRequest.tensors)
  return _internal_tensors(index);
}
inline std::string* ModelRequest::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:flexe.ModelRequest.tensors)
  return tensors_.Mutable(index);
}
inline void ModelRequest::set_tensors(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:flexe.ModelRequest.tensors)
  tensors_.Mutable(index)->assign(value);
}
inline void ModelRequest::set_tensors(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:flexe.ModelRequest.tensors)
  tensors_.Mutable(index)->assign(std::move(value));
}
inline void ModelRequest::set_tensors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tensors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flexe.ModelRequest.tensors)
}
inline void ModelRequest::set_tensors(int index, const void* value, size_t size) {
  tensors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flexe.ModelRequest.tensors)
}
inline std::string* ModelRequest::_internal_add_tensors() {
  return tensors_.Add();
}
inline void ModelRequest::add_tensors(const std::string& value) {
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flexe.ModelRequest.tensors)
}
inline void ModelRequest::add_tensors(std::string&& value) {
  tensors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flexe.ModelRequest.tensors)
}
inline void ModelRequest::add_tensors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flexe.ModelRequest.tensors)
}
inline void ModelRequest::add_tensors(const void* value, size_t size) {
  tensors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flexe.ModelRequest.tensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelRequest::tensors() const {
  // @@protoc_insertion_point(field_list:flexe.ModelRequest.tensors)
  return tensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelRequest::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:flexe.ModelRequest.tensors)
  return &tensors_;
}

// int32 number_of_vehicles = 3;
inline void ModelRequest::clear_number_of_vehicles() {
  number_of_vehicles_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::_internal_number_of_vehicles() const {
  return number_of_vehicles_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::number_of_vehicles() const {
  // @@protoc_insertion_point(field_get:flexe.ModelRequest.number_of_vehicles)
  return _internal_number_of_vehicles();
}
inline void ModelRequest::_internal_set_number_of_vehicles(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_of_vehicles_ = value;
}
inline void ModelRequest::set_number_of_vehicles(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number_of_vehicles(value);
  // @@protoc_insertion_point(field_set:flexe.ModelRequest.number_of_vehicles)
}

// int32 num_examples = 4;
inline void ModelRequest::clear_num_examples() {
  num_examples_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::_internal_num_examples() const {
  return num_examples_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelRequest::num_examples() const {
  // @@protoc_insertion_point(field_get:flexe.ModelRequest.num_examples)
  return _internal_num_examples();
}
inline void ModelRequest::_internal_set_num_examples(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_examples_ = value;
}
inline void ModelRequest::set_num_examples(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_examples(value);
  // @@protoc_insertion_point(field_set:flexe.ModelRequest.num_examples)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flexe

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flexe_2eproto
